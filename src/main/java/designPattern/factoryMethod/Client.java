package designPattern.factoryMethod;

/**
 * @Description 场景类
 * Author caihaojie
 * @Date 2020-04-09 14:05
 **/
public class Client {

    public static void main(String[] args) {
        Creator creator = new ConcreteCreator();
        Product product = creator.createProduct(ConcreteProduct1.class);
        // 后续的业务逻辑
    }

}
/**
 * 优点
 * 良好的封装性，代码结构清晰
 * 扩展性好
 * 屏蔽产品类，调用者不用关心产品类
 * 典型的解耦框架，高层模块只需要知道产品的抽象类，其他实现都不用关心
 */

/**
 * 使用场景
 */
/**
 * 首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以
 * 使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。
 *
 * 其次，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。万物皆对象，那万
 * 物也就皆产品类，例如需要设计一个连接邮件服务器的框架，有三种网络协议可供选择：
 * POP3、IMAP、HTTP，我们就可以把这三种连接方法作为产品类，定义一个接口如 IConnectMail，然后定义对邮件的操作方法，
 * 不同的方法实现三个具体的产品类（也就是连接方式）再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。
 * 如此设计，可以做到完美的扩展，如某些邮件服务器提供了WebService接口，很好，我们只要增加一个产品类就可以了。
 *
 * 再次，工厂方法模式可以用在异构项目中，例如通过WebService与一个非Java的项目交互，
 * 虽然WebService号称是可以做到异构系统的同构化，但是在实际的开发中，还是会碰到 很多问题，如类型问题、WSDL文件的支持问题，等等。从WSDL中产生的对象都认为是一
 * 个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。
 *
 * 最后，可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关 联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B 的耦合。
 * 目前由于JMock和EasyMock的诞生，该使用场景已经弱化了，读者可以在遇到此种 情况时直接考虑使用JMock或EasyMock。
 */
